---
import CarouselItem from "./CarouselItem.astro";

interface Item {
  id: string;
  title: string;
  img: ImageMetadata | string;
  alt: string;
  href?: string;
  rating?: number;
}
interface Props {
  title: string;
  category?: string;
  items: Item[];
}
const { title, category, items = [] } = Astro.props as Props;

const repeatedItems = Array.from({ length: 3 }, () => items).flat();
---

<section class="relative flex flex-col gap-2 bg-[#141414]" data-carousel-root data-loop="true">
  <h2 class="px-6 pt-6 text-[28px] font-extrabold tracking-[-0.02em] text-white md:text-[32px]">
    {title}
  </h2>

  <div class="relative px-6 pb-8">
    <div class="pointer-events-none absolute left-0 top-0 h-full w-10 bg-gradient-to-r from-[#141414] to-transparent"></div>
    <div class="pointer-events-none absolute right-0 top-0 h-full w-10 bg-gradient-to-l from-[#141414] to-transparent"></div>

    <div
      data-carousel-track
      class="no-scrollbar flex snap-x snap-mandatory gap-3 overflow-x-auto scroll-smooth"
      role="list"
      aria-label={`Carrossel ${title}`}
      tabindex="0"
    >
      {repeatedItems.map((item, idx) => (
        <div role="listitem" class="snap-start">
          <CarouselItem {...item} />
        </div>
      ))}
    </div>

    <button
      type="button"
      data-dir="left"
      aria-label="Anterior"
      class="group absolute left-2 top-1/2 -translate-y-1/2 rounded-full bg-white/10 p-2 backdrop-blur transition hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/40 z-10"
    >
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" class="text-white">
        <path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </button>
    <button
      type="button"
      data-dir="right"
      aria-label="PrÃ³ximo"
      class="group absolute right-2 top-1/2 -translate-y-1/2 rounded-full bg-white/10 p-2 backdrop-blur transition hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/40 z-10"
    >
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" class="text-white">
        <path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      </svg>
    </button>
  </div>
</section>

<script is:inline>
  document.querySelectorAll('[data-carousel-root][data-loop="true"]').forEach((root) => {
    const track = root.querySelector('[data-carousel-track]');
    const btnLeft = root.querySelector('[data-dir="left"]');
    const btnRight = root.querySelector('[data-dir="right"]');
    if (!track || !btnLeft || !btnRight) return;

    track.classList.add('js-ready');
    function snapOff() {
      track.classList.add('snap-off', 'no-smooth');
      void track.offsetHeight;
    }
    function snapOn() {
      requestAnimationFrame(() => {
        track.classList.remove('snap-off', 'no-smooth');
      });
    }

    const sets = 3; // A | A | A
    function getSetWidth() {
      return track.scrollWidth / sets;
    }
    function getStep() {
      const first = track.querySelector(':scope > *');
      if (!first) return 320;
      const rect = first.getBoundingClientRect();
      const styles = window.getComputedStyle(track);
      const gap = parseFloat(styles.gap || styles.columnGap || '12');
      return rect.width + gap;
    }

    function goToMiddleSet() {
      const setW = getSetWidth();
      snapOff();
      track.scrollLeft = setW;
      snapOn();
    }

    function keepInfinite() {
      const setW = getSetWidth();
      const l = track.scrollLeft;
      if (l < setW * 0.5) {
        snapOff();
        track.scrollLeft = l + setW; 
        snapOn();
      } else if (l >= setW * 1.5) {
        snapOff();
        track.scrollLeft = l - setW;
        snapOn();
      }
    }

    function scrollDir(dir) {
      track.scrollBy({ left: dir === 'right' ? getStep() : -getStep(), behavior: 'smooth' });
    }

    btnLeft.addEventListener('click', () => scrollDir('left'));
    btnRight.addEventListener('click', () => scrollDir('right'));
    track.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') { e.preventDefault(); scrollDir('right'); }
      if (e.key === 'ArrowLeft')  { e.preventDefault(); scrollDir('left'); }
    });

    track.addEventListener('scroll', keepInfinite, { passive: true });
    window.addEventListener('resize', () => {
      clearTimeout(track._loopResizeT);
      track._loopResizeT = setTimeout(goToMiddleSet, 80);
    });

    queueMicrotask(goToMiddleSet);
  });
</script>

<style>
  .no-scrollbar::-webkit-scrollbar { display: none; }
  .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

  .snap-off { scroll-snap-type: none !important; }
  .no-smooth { scroll-behavior: auto !important; }
</style>
